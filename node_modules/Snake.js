'use strict';
var DIRECTION = require('Direction');
var BLOCK_TYPE = require('BlockType');
var CLASS_NAMES = require('ClassNames');

function Snake(name, coords, color, speed, controls, direction, socket, classNames) {
	this.name = name;
	this.coords = coords;
	this.color = color;
	this.speed = speed;
	this.controls = controls;
	this.direction = direction;
	this.socket = socket;
	this.points = 0;

	var that = this;
	this.socket.on('key pressed', function(key){
		switch (key) {
			case that.controls.left:
				if (that.direction !== DIRECTION.RIGHT) {
					that.turnLeft();
				}
				break;
			case that.controls.right:
				if (that.direction !== DIRECTION.LEFT) {
					that.turnRight();
				}
				break;
			case that.controls.up:
				if (that.direction !== DIRECTION.DOWN) {
					that.turnUp();
				}
				break;
			case that.controls.down:
				if (that.direction !== DIRECTION.UP) {
					that.turnDown();
				}
				break;
		}
	});
};

Snake.prototype = {
	crashIntoWall : function() {
		this.socket.emit('game over');
		return true;
	},

	crashIntoSelf : function() {
		this.socket.emit('game over');
		return true;
	},

	checkForCollisions : function(field, block) {		
		if (field[block.y][block.x] === BLOCK_TYPE.WALL) {
			console.log('wall');
			return this.crashIntoWall();
		}
		if (this.coords.filter(function(e) { return e.x === block.x && e.y === block.y; }).length > 0) {
			console.log('self');
 			return this.crashIntoSelf();
		}

		return false;
	},

	eatFruit : function(fruit, field) {
		this.socket.emit('erase block', fruit.coords[0], CLASS_NAMES[BLOCK_TYPE.BLANK]);
		fruit.generatePosition(field, this);
		this.socket.emit('render block', fruit.coords, CLASS_NAMES[BLOCK_TYPE.FRUIT]);
		this.points += fruit.points;
		this.socket.emit('update points', this.points);
	},

	checkForFruit : function(fruit, field, block){
		if (block.y === fruit.coords.y && block.x === fruit.coords.x) {
			this.eatFruit.call(this, fruit, field);
			return true;
		}

		return false;
	},	

	accelerate : function(value) {

	},

	move : function(fruit, field){		
		var lastBlock = this.coords[this.coords.length - 1];
		var newBlock;		

		switch(this.direction) {
		    case DIRECTION.LEFT:		    
				newBlock = {x:lastBlock.x - 1, y: lastBlock.y};				        
		        break;
		    case DIRECTION.RIGHT:
		    	newBlock = {x:lastBlock.x + 1, y: lastBlock.y};
		        break;
		    case DIRECTION.UP:
		    	newBlock = {x:lastBlock.x, y: lastBlock.y - 1};
		        break;
	        case DIRECTION.DOWN:
	    		newBlock = {x:lastBlock.x, y: lastBlock.y + 1};
	        	break;
		}

		if(this.checkForCollisions.call(this, field, newBlock)){
			console.log('collision with block ' + newBlock.x + ' ' + newBlock.y);
			return true;
		}

		if (this.checkForFruit.call(this, fruit, field, newBlock) === false) {
			this.socket.emit('erase block', this.coords[0], CLASS_NAMES[BLOCK_TYPE.BLANK]);
			this.coords.shift();
		}
		
		this.coords.push(newBlock);

		this.socket.emit('render block', newBlock, CLASS_NAMES[BLOCK_TYPE.SNAKE]);

		return false;
	},

	turnLeft : function() {
		this.direction = DIRECTION.LEFT;
	},

	turnRight : function() {
		this.direction = DIRECTION.RIGHT;
	},

	turnUp : function(){
		this.direction = DIRECTION.UP;
	},

	turnDown : function(){
		this.direction = DIRECTION.DOWN;
	}
};

module.exports = Snake;